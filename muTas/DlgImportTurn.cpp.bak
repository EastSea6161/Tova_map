// DlgImportTurn.cpp : 구현 파일입니다.
//

#include "stdafx.h"
#include "KmzApp.h"
#include "DlgImportTurn.h"
#include "afxdialogex.h"
#include "DefineNames.h"
#include "..\QBicCommon\QBicTxtReader.h"
#include "..\QBicCommon\QBicTxtWriter.h"
#include "DBaseImportTable.h"
#include "ImportCommon.h"
#include "Target.h"
#include "ImChampFrameWindow.h"
#include "KDlgTurnTypeEdit.h"

enum
{
	_0_COLUMN_DEFFILED_NAME = 0,
	_1_COLUMN_DEFFILED_TYPE,
	//_2_COLUMN_DEFFILED_PK_YN,
	_2_COLUMN_IMPORTFIELD_NAME
};

// KDlgImportTurn 대화 상자입니다.

IMPLEMENT_DYNAMIC(KDlgImportTurn, KWhiteDlgEx)

KDlgImportTurn::KDlgImportTurn(KTarget* a_pTarget, KIOTable* a_pTable, CWnd* pParent /*=NULL*/)
	: KWhiteDlgEx(KDlgImportTurn::IDD, pParent)
	, m_pTarget(a_pTarget)
	, m_pTable(a_pTable)
	, m_strTableName(_T(""))
	, m_nStartNum(1)
	, m_bAutoGenerateKey(FALSE)
	, VIRTUAL_FIELD_FROMNODE(_T("F_Node_ID"))
	, VIRTUAL_FIELD_TONODE(_T("T_Node_ID"))
{
	if (nullptr != m_pTable) {
		m_strTableName = m_pTable->Name();
	}

	CString strTargetLocation = m_pTarget->GetLocation();

	m_strErrFile.Format   (_T("%s\\%s"), strTargetLocation, IMPORT_ERROR_FILE_NAME);
	m_strMiddleFile.Format(_T("%s\\%s"), strTargetLocation, IMPORT_FILE_NAME);

	m_mapSeparator.clear(); {
		TSeparator oTSeparator;
		oTSeparator.nCode = 0;
		oTSeparator.tcSeparator = _T(',');
		oTSeparator.strDispName = _T("Comma(,)");
		m_mapSeparator.insert(std::make_pair(oTSeparator.nCode, oTSeparator));

		oTSeparator.nCode = 1;
		oTSeparator.tcSeparator = _T(';');
		oTSeparator.strDispName = _T("Semicolon(;)");
		m_mapSeparator.insert(std::make_pair(oTSeparator.nCode, oTSeparator));

		oTSeparator.nCode = 2;
		oTSeparator.tcSeparator = _T('|');
		oTSeparator.strDispName = _T("Pipe(|)");
		m_mapSeparator.insert(std::make_pair(oTSeparator.nCode, oTSeparator));

		oTSeparator.nCode = 3;
		oTSeparator.tcSeparator = _T('	');
		oTSeparator.strDispName = _T("Tab");
		m_mapSeparator.insert(std::make_pair(oTSeparator.nCode, oTSeparator));
	}
}

KDlgImportTurn::~KDlgImportTurn()
{
}

void KDlgImportTurn::DoDataExchange(CDataExchange* pDX)
{
	KWhiteDlgEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_REPORT1,    m_ctrlReportColumn);
	DDX_Control(pDX, IDC_REPORT2,    m_ctrlReportPreview);
	DDX_Control(pDX, IDC_REPORT7,    m_ctrlReportSampleColumn);

	DDX_Control(pDX, IDC_COMBO3,     m_cboBaseDataType);

	DDX_Control(pDX, IDC_FILENAME2, m_editFile);
	DDX_Control(pDX, IDC_COMBO5, m_cboSeparator);
	DDX_Control(pDX, IDC_COMBO4, m_cboEncoding);
}


BEGIN_MESSAGE_MAP(KDlgImportTurn, KWhiteDlgEx)
	ON_BN_CLICKED(IDOK,       &KDlgImportTurn::OnBnClickedOk)
	ON_BN_CLICKED(IDC_CHECK3, &KDlgImportTurn::OnBnClickedCheckAuto)

	ON_CBN_SELCHANGE(IDC_COMBO3, &KDlgImportTurn::OnSelchangeComboBaseDataType)

	ON_NOTIFY(XTP_NM_REPORT_RECORDS_DROPPED,      IDC_REPORT1,     &KDlgImportTurn::OnReportRecordsDropped)
	ON_NOTIFY(XTP_NM_REPORT_DROP,                 IDC_REPORT7,     &KDlgImportTurn::OnReportDropSampleColumn)
	ON_BN_CLICKED(IDC_CHECK4, &KDlgImportTurn::OnBnClickedCheckDefault)
	ON_BN_CLICKED(IDCANCEL, &KDlgImportTurn::OnBnClickedCancel)

	ON_EN_CHANGE(IDC_FILENAME2, &KDlgImportTurn::OnEnChangeFilename)
	ON_CBN_SELCHANGE(IDC_COMBO4, &KDlgImportTurn::OnCbnSelchangeCombo4)
	ON_CBN_SELCHANGE(IDC_COMBO5, &KDlgImportTurn::OnCbnSelchangeCombo5)
	ON_BN_CLICKED(IDC_CHECK1, &KDlgImportTurn::OnBnClickedCheck1)
END_MESSAGE_MAP()


// KDlgImportTurn 메시지 처리기입니다.
void KDlgImportTurn::ResizeComponent()
{
	try 
	{
		SetResize(IDC_FILENAME2,    SZ_TOP_LEFT,	SZ_TOP_RIGHT);
		SetResize(IDC_STATIC7,		SZ_TOP_LEFT,	SZ_TOP_RIGHT);

		SetResize(IDC_STATIC1,		SZ_TOP_LEFT,	SZ_TOP_RIGHT);

		SetResize(IDC_REPORT1,	    SZ_TOP_LEFT,	CXTPResizePoint(.8f, .5));
		SetResize(IDC_REPORT7,		CXTPResizePoint(.8f, 0),	SZ_MIDDLE_RIGHT);
		SetResize(IDC_STATIC5,		SZ_MIDDLE_LEFT,	SZ_MIDDLE_RIGHT);

		SetResize(IDC_STATIC3,		SZ_MIDDLE_LEFT,	SZ_MIDDLE_LEFT);

		SetResize(IDC_REPORT2,		SZ_MIDDLE_LEFT,	SZ_BOTTOM_RIGHT);
		SetResize(IDC_STATIC2,		SZ_BOTTOM_LEFT,	SZ_BOTTOM_RIGHT);

		SetResize(IDC_STATIC_SEP,	SZ_BOTTOM_LEFT,	SZ_BOTTOM_LEFT);
		SetResize(IDC_COMBO5,		SZ_BOTTOM_LEFT,	SZ_BOTTOM_LEFT);
		SetResize(IDC_STATIC_ENC,	SZ_BOTTOM_LEFT,	SZ_BOTTOM_LEFT);
		SetResize(IDC_COMBO4,		SZ_BOTTOM_LEFT,	SZ_BOTTOM_LEFT);
		SetResize(IDC_CHECK1,		SZ_BOTTOM_LEFT,	SZ_BOTTOM_LEFT);
		
		SetResize(IDOK,				SZ_BOTTOM_RIGHT,SZ_BOTTOM_RIGHT);
		SetResize(IDCANCEL,			SZ_BOTTOM_RIGHT,SZ_BOTTOM_RIGHT);
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::InitComboBaseDataType()
{
	m_cboBaseDataType.ResetContent();

	int nCurSel;
	if (KmzSystem::GetLanguage() == KEMKorea) {
		nCurSel = m_cboBaseDataType.AddString(_T("노드 기반"));
	}
	else
	{
		nCurSel = m_cboBaseDataType.AddString(_T("NodeBase"));
	}
	m_cboBaseDataType.SetItemData(nCurSel, KEMBaseNode);
	if (KmzSystem::GetLanguage() == KEMKorea) {
		nCurSel     = m_cboBaseDataType.AddString(_T("링크 기반"));
	}
	else
	{
		nCurSel     = m_cboBaseDataType.AddString(_T("LinkBase"));
	}
	m_cboBaseDataType.SetItemData(nCurSel, KEMBaseLink);

	m_cboBaseDataType.SetCurSel(0);
}

void KDlgImportTurn::InitBaseDataTypeUI()
{
	UpdateData(TRUE);

	BOOL bShow = FALSE;

	KEMImportType emImportType = GetSelectedImportType();
}

void KDlgImportTurn::InitAutoGenerateUI( void )
{
	UpdateData(TRUE);

	KEMImportType emImportType = GetSelectedImportType();

	CString strDlgText  (_T(""));
	if(KEMImportInsert == emImportType) {
		strDlgText.Format(_T("Auto Generate %s   From :"), COLUMN_TURN_ID);
	}
	strDlgText.Format(_T("Generate Link ID : from"));
	if (KmzSystem::GetLanguage() == KEMKorea) {
        strDlgText.Format(_T("ID 자동 생성 :"));
    }

	SetDlgItemText(IDC_CHECK3, strDlgText);
	CheckDlgButton(IDC_CHECK3, BST_CHECKED);
}


KEMImportType KDlgImportTurn::GetSelectedImportType()
{
	return KEMImportInsert; // Turn은 오직 New모드만 작동
}


BOOL KDlgImportTurn::OnInitDialog()
{
	KWhiteDlgEx::OnInitDialog();
	KWhiteDlgEx::UseKeyEscEnter(true, true);

	HICON hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_DLG_ICO) );
	SetIcon( hIcon, TRUE );
	SetIcon( hIcon, FALSE );

 	ResizeComponent();

	InitComboSeparator();
	InitComboEncoding();

	if (true) { // 입력창 설정
		TCHAR szFilter[] = _T("Txt Files (*.txt)|*.txt|All Files (*.*)|*.*||");
		m_editFile.Initialize( this, BES_XT_CHOOSEFILE );
		m_editFile.SetDlgOpenFile( TRUE );
		m_editFile.SetReadOnly( TRUE );
		m_editFile.SetDlgTitle( _T("Select file") );
		m_editFile.SetDlgFilter( szFilter );

		m_editFile.SetDlgInitialDir(m_pTarget->GetLocation());
	}
 
	SetDlgItemInt(IDC_EDIT1, 1);
	InitAutoGenerateUI();
 	InitBaseDataTypeUI();
	InitComboBaseDataType();
 
	QBicReportCtrlSetting::Default(m_ctrlReportColumn, TRUE, FALSE, FALSE);
	QBicReportCtrlSetting::Default(m_ctrlReportSampleColumn, TRUE);
	QBicReportCtrlSetting::Default(m_ctrlReportPreview, FALSE, FALSE, FALSE);

	CheckDlgButton(IDC_CHECK4, BST_CHECKED);

	InitializeSampleColumnReport();
	InitializeColumnField();

	m_ctrlReportColumn.EnableDragDrop      (_T("TestDragDrop"), xtpReportAllowDrop, xtpReportDropSelect);
	m_ctrlReportSampleColumn.EnableDragDrop(_T("TestDragDrop"), xtpReportAllowDragCopy | xtpReportAllowDrop, xtpReportDropSelect);

	return TRUE;  // return TRUE unless you set the focus to a control
	// 예외: OCX 속성 페이지는 FALSE를 반환해야 합니다.
}

void KDlgImportTurn::OnEnChangeFilename()
{
	UpdateData( TRUE );

	CString strFile(_T("")); {
		m_editFile.GetWindowText( strFile );
		if (strFile.IsEmpty())
			return;
	}

	// 디폴트 구분자 설정
	CheckDefaultSeperator(strFile);

	// 디폴트 인코딩 설정
	int nEncoding = CheckEncoding(strFile);
	if (KEMCSVEncodingUTF8 == nEncoding)
		m_cboEncoding.SetCurSel(1);
	else // 
		m_cboEncoding.SetCurSel(0);

	if (CheckImportHeader(strFile)) {
		CheckDlgButton(IDC_CHECK1, BST_CHECKED);
	} else {
		CheckDlgButton(IDC_CHECK1, BST_UNCHECKED);
	}

	if( PriviewLoadCSV() ) {
		InitializeColumnField();
		UpdateColumnView();
		InitializePreview();

		ControlDefaultCheck();
	} 
}

void KDlgImportTurn::CheckDefaultSeperator(CString a_strFile)
{
	try
	{
		QBicTxtReader oReader; {
			if (oReader.Open(a_strFile) == false) {
				throw 1;
			}
		}

		CString strLine(_T(""));
		oReader.ReadLine(strLine);

		int nSeparator(0);
		int nMax = -9; // 하나씩 파싱을 해보고 파싱된 결과가 가장 많은 개수인 구분자를 디폴트 구분자로.. 

		auto iter  = m_mapSeparator.begin();
		auto itEnd = m_mapSeparator.end();

		for (; iter != itEnd; ++iter) {
			const int  &nCode       = iter->first;
			TSeparator &oTSeparator = iter->second;

			std::vector<CString> vecSelect = QBicSplit::Split(strLine, oTSeparator.tcSeparator);

			int nSizeVec = (int)vecSelect.size();
			if (nSizeVec > nMax) {
				nMax = nSizeVec;
				nSeparator = nCode;
			}
		}

		m_cboSeparator.SetCurSel(nSeparator);

		oReader.Close();
	} catch (int& ex) {
		CString strMsg(_T(""));
		if (1 == ex)
			strMsg = _T("Fail - Read TextFile");
		else
			strMsg.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strMsg);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}

	UpdateData(FALSE);
}

bool KDlgImportTurn::CheckImportHeader(CString a_strFile)
{
	try
	{
		QBicTxtReader oReader; {
			if (oReader.Open(a_strFile) == false) {
				throw 1;
			}
		}

		TCHAR tcSeparator; {
			int nCurSel = m_cboSeparator.GetCurSel();
			int nCode   = (int)m_cboSeparator.GetItemData(nCurSel);

			auto itFind = m_mapSeparator.find(nCode);
			if (itFind != m_mapSeparator.end()) {
				TSeparator &oTSeparator = itFind->second;
				tcSeparator = oTSeparator.tcSeparator;
			}
		}

		std::vector<CString> vecSelect;
		oReader.ReadLine(tcSeparator, vecSelect);
		oReader.Close();

		bool bFirstColumnHeader(false);
		CString strSample = vecSelect[0]; // 한줄을 읽고, 맨앞 데이터 하나를 Sample로..
		if (QBicStringChecker::IsNumeric(strSample)) { // 숫자라면, 일반 데이터
			bFirstColumnHeader = false;
		} else { // 문자라면, Header일 것이다.
			bFirstColumnHeader = true;
		}

		return bFirstColumnHeader;

	} catch (int& ex) {
		CString strMsg(_T(""));
		if (1 == ex)
			strMsg = _T("Fail - Read TextFile");
		else
			strMsg.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strMsg);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}

	UpdateData(FALSE);

	return false;
}

int KDlgImportTurn::CheckEncoding(CString a_strFile, bool a_bAlarmErr)
{
	try
	{
		int nEncoding = KEMCSVEncodingUnknown; {
			QBicTxtReader oReader;
			nEncoding = oReader.GetTxtFileEncoding(a_strFile);

			if (nEncoding != KEMCSVEncodingUTF8 && nEncoding != KEMCSVEncodingANSI)	
				throw 9;
		}

		return nEncoding; // 성공
	} catch (int& ex) {
		CString strMsg(_T(""));
		if (KmzSystem::GetLanguage() == KEMKorea) {
			if (1 == ex)
				strMsg = _T("인코딩 인식에 실패하였습니다.");
			else if (9 == ex)
				strMsg = _T("ANSI와 UTF-8 인코딩 파일만 인식 가능합니다.");
			else
				strMsg.Format(_T("오류 : %d"), ex);
		}
		else {
			if (1 == ex)
				strMsg = _T("Encoding recognition failed.");
			else if (9 == ex)
				strMsg = _T("Only ANSI and UTF-8 encoded files are available.");
			else
				strMsg.Format(_T("Error : %d"), ex);
		}
		
		TxLogDebug((LPCTSTR)strMsg);
		if (a_bAlarmErr)
			AfxMessageBox(strMsg);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		if (a_bAlarmErr)
			AfxMessageBox(ex->GetErrorMessage());
	} catch (...) {
		TxLogDebugException();
		if (a_bAlarmErr) {
			if (KmzSystem::GetLanguage() == KEMKorea) {
				AfxMessageBox(_T("인코딩 인식에 실패하였습니다."));
			}
			else {
				AfxMessageBox(_T("Encoding recognition failed."));
			}
		}
			
	}

	return KEMCSVEncodingUnknown;
}

void KDlgImportTurn::InitComboSeparator()
{
	try
	{
		m_cboSeparator.ResetContent();

		auto iter  = m_mapSeparator.begin();
		auto itEnd = m_mapSeparator.end();

		for (; iter != itEnd; ++iter)
		{
			const int  &nCode       = iter->first;
			TSeparator &oTSeparator = iter->second;

			int nCur = m_cboSeparator.AddString(oTSeparator.strDispName);
			m_cboSeparator.SetItemData(nCur, (DWORD_PTR)oTSeparator.nCode);
		}

		m_cboSeparator.SetCurSel(3);
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::InitComboEncoding()
{
	try
	{
		m_cboEncoding.ResetContent();
		int nCur = m_cboEncoding.AddString(_T("ANSI"));
		m_cboEncoding.SetItemData(nCur, (DWORD_PTR)1);

		nCur = m_cboEncoding.AddString(_T("UTF-8"));
		m_cboEncoding.SetItemData(nCur, (DWORD_PTR)2);

		m_cboEncoding.SetCurSel(0);
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::InitializeColumnField( void )
{
	TxLogDebugStartMsg();

	try 
	{
		m_ctrlReportColumn.ResetContent();
		m_ctrlReportColumn.GetColumns()->Clear();
		m_ctrlReportColumn.Populate();

		// Field
		CXTPReportColumn* pColumn = m_ctrlReportColumn.AddColumn( new CXTPReportColumn( _0_COLUMN_DEFFILED_NAME, _T("System Column"), 30 ) );
		pColumn->GetEditOptions()->m_bAllowEdit = FALSE;
		pColumn->SetHeaderAlignment(DT_CENTER);
		pColumn->SetAlignment( DT_CENTER );
		if (KmzSystem::GetLanguage() == KEMKorea) {
			pColumn->SetCaption(_T("시스템 컬럼"));
		}

		// type
		pColumn = m_ctrlReportColumn.AddColumn( new CXTPReportColumn( _1_COLUMN_DEFFILED_TYPE, _T("Type"), 16 ) );
		pColumn->GetEditOptions()->m_bAllowEdit = FALSE;
		pColumn->SetHeaderAlignment(DT_CENTER);
		pColumn->SetAlignment( DT_CENTER );
		if (KmzSystem::GetLanguage() == KEMKorea) {
			pColumn->SetCaption(_T("데이터 유형"));
		}

		// Primary key
// 		pColumn = m_ctrlReportColumn.AddColumn( new CXTPReportColumn( _2_COLUMN_DEFFILED_PK_YN, _T("Primary Key"), 25 ) );
// 		pColumn->GetEditOptions()->m_bAllowEdit = FALSE;
// 		pColumn->SetHeaderAlignment(DT_CENTER);
// 		pColumn->SetAlignment( DT_CENTER );

		// column
		CXTPReportColumn* pImport = m_ctrlReportColumn.AddColumn( new CXTPReportColumn( _2_COLUMN_IMPORTFIELD_NAME, _T("File Column"), 33 ) );
		if (KmzSystem::GetLanguage() == KEMKorea) {
			pImport->SetCaption(_T("파일 컬럼"));
		}

		m_ctrlReportSampleColumn.ResetContent();

		/// csv 파일의 컬럼을 combo에 추가, 0 = NULL, 1~... = Column Name
		if (m_ColumnRow.size() > 0) {
			int nColumnIndex(0);

			CString strNull(_T("Null"));
			pImport->GetEditOptions()->AddConstraint( strNull, nColumnIndex);
			UpdateReportDataSampleColumn(strNull, nColumnIndex);
			nColumnIndex++; 

			auto itColumnArray  = m_ColumnRow.begin();
			auto itEnd          = m_ColumnRow.end();
			for (; itColumnArray != itEnd; ++itColumnArray, nColumnIndex++) {
				pImport->GetEditOptions()->AddConstraint( *itColumnArray, nColumnIndex );
				UpdateReportDataSampleColumn(*itColumnArray, nColumnIndex);
			}

			m_ctrlReportSampleColumn.Populate();
		}

		pImport->SetHeaderAlignment(DT_CENTER);
		pImport->SetAlignment( DT_CENTER );
		pImport->GetEditOptions()->m_bAllowEdit = TRUE;
		pImport->GetEditOptions()->m_bExpandOnSelect = TRUE;
		pImport->GetEditOptions()->AddComboButton( TRUE );	
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}

	TxLogDebugEndMsg();
}

void KDlgImportTurn::UpdateReportDataSampleColumn(CString a_strColName, int a_nIndex)
{
	try 
	{
		CXTPReportRecord*     pRecord = m_ctrlReportSampleColumn.AddRecord(new CXTPReportRecord);
		CXTPReportRecordItem* pItem   = pRecord->AddItem(new CXTPReportRecordItemText(a_strColName));
		pItem->SetAlignment(DT_CENTER);
		pItem->SetItemData(a_nIndex);
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::InitializeSampleColumnReport()
{
	try 
	{
		CXTPReportColumn* pColumn = m_ctrlReportSampleColumn.AddColumn( new CXTPReportColumn( 0, _T("Drag & Drop"), 100 ) );
		pColumn->SetHeaderAlignment(DT_CENTER);
		pColumn->SetSortable(FALSE);
		pColumn->SetEditable(FALSE);
		if (KmzSystem::GetLanguage() == KEMKorea) {
			pColumn->SetCaption(_T("끌어 놓기"));
		}

		m_ctrlReportSampleColumn.Populate();
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::UpdateColumnView()
{
	CheckDlgButton(IDC_CHECK4, BST_CHECKED);

	if (GetBaseDataType() == KEMBaseNode) {
		UpdateColumnRecordByNode();
	} else {
		UpdateColumnRecord();
	}
}

void KDlgImportTurn::UpdateColumnRecord( void )
{
	TxLogDebugStartMsg();
	UpdateData(TRUE);

	m_ctrlReportColumn.ResetContent();
	if (m_ColumnRow.size() < 1) {
		return;
	}

	try
	{
		int nCSVIndex(0);
		auto itCSVColumn = m_ColumnRow.begin();

		const KIOColumns* pColumns         = m_pTable->Columns();
		int               nColumnCount     = pColumns->ColumnCount();
		KEMImportType     emImportType     = GetSelectedImportType();
		BOOL              bAutoGenerateKey = IsAutoGenerateKey();

		for (int i= 0; i< nColumnCount; i++) {
			KIOColumn*            pColumn  = pColumns->GetColumn(i);

			CString               strColNm = pColumn->Name();
			CXTPReportRecord*     pRecord  = m_ctrlReportColumn.AddRecord(new CXTPReportRecord);
			CXTPReportRecordItem* pItem    = nullptr;

            bool bRed(false);
            CString strField(_T("")); {
                if (strColNm.CompareNoCase(COLUMN_TURN_ID)     == 0  ||
                    strColNm.CompareNoCase(COLUMN_TURN_F_LINK) == 0  ||
                    strColNm.CompareNoCase(COLUMN_TURN_NODE)   == 0  ||
                    strColNm.CompareNoCase(COLUMN_TURN_T_LINK) == 0 ) 
                {
                    strField.Format(_T("* %s"), pColumn->Caption());
                    bRed = true;
                }
                else {
                    strField.Format(_T("%s"), pColumn->Caption());
                }
            }

            pItem = pRecord->AddItem(new CXTPReportRecordItemText(strField)); {
                pItem->SetItemData((DWORD_PTR)pColumn);
                if (bRed) {
                    pItem->SetTextColor(RGB(255,0,0));
                }
            }			

			// type
			CString strDataType(_T(""));
			switch(pColumn->DataType())
			{
			case KEMIODataTypeInteger : strDataType = DATATYPESTRING_INTEGER; break;
			case KEMIODataTypeDouble  : strDataType = DATATYPESTRING_DOUBLE;  break;
			case KEMIODataTypeString  : strDataType = DATATYPESTRING_STRING;  break;
			}
			pRecord->AddItem(new CXTPReportRecordItemText(strDataType));

			if (TRUE == bAutoGenerateKey) {
				if (strColNm.CompareNoCase(COLUMN_LINK_ID) == 0 || strColNm.CompareNoCase(COLUMN_TURN_ID) == 0) {
					pRecord->AddItem(new KColumnReportRecordItem(1));
					pRecord->SetVisible(FALSE);
					continue;
				}
			}

			// column
			if(m_ColumnRow.end() == itCSVColumn) {
				pRecord->AddItem(new KColumnReportRecordItem(0));
			} else {
				pRecord->AddItem(new KColumnReportRecordItem(++nCSVIndex));
				++itCSVColumn;
			}
		}

		m_ctrlReportColumn.GetReportHeader()->AllowColumnRemove( FALSE );
		m_ctrlReportColumn.FocusSubItems( TRUE );
		m_ctrlReportColumn.Populate();
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}

	TxLogDebugEndMsg();
}

void KDlgImportTurn::UpdateColumnRecordByNode( void )
{
	TxLogDebugStartMsg();
	UpdateData(TRUE);

	m_ctrlReportColumn.ResetContent();
	if (m_ColumnRow.size() < 1) {
		return;
	}

	try
	{
		int nCSVIndex(0);
		auto itCSVColumn = m_ColumnRow.begin();

		const KIOColumns* pColumns         = m_pTable->Columns();
		int               nColumnCount     = pColumns->ColumnCount();
		KEMImportType     emImportType     = GetSelectedImportType();
		BOOL              bAutoGenerateKey = IsAutoGenerateKey();


		for (int i= 0; i< nColumnCount; i++) {
			KIOColumn*            pColumn  = pColumns->GetColumn(i);

			CString               strColNm = pColumn->Name();
			CXTPReportRecord*     pRecord  = m_ctrlReportColumn.AddRecord(new CXTPReportRecord);
			CXTPReportRecordItem* pItem    = nullptr;

			// field
            bool bRed(false);
			CString strField(_T("")); {
				CString strTempField(_T("")); {					
					if (strColNm.CompareNoCase(COLUMN_TURN_F_LINK) == 0)
						strTempField = VIRTUAL_FIELD_FROMNODE;
					else if (strColNm.CompareNoCase(COLUMN_TURN_T_LINK) == 0)
						strTempField = VIRTUAL_FIELD_TONODE;
                    else 
                        strTempField = pColumn->Caption();
				}

                if (strColNm.CompareNoCase(COLUMN_TURN_ID)     == 0  ||
                    strColNm.CompareNoCase(COLUMN_TURN_F_LINK) == 0  ||
                    strColNm.CompareNoCase(COLUMN_TURN_NODE)   == 0  ||
                    strColNm.CompareNoCase(COLUMN_TURN_T_LINK) == 0   ) {
					strField.Format(_T("* %s"), strTempField);
                    bRed = true;
                }
				else {
					strField.Format(_T("%s"), strTempField);
                }
			}
            
            pItem = pRecord->AddItem(new CXTPReportRecordItemText(strField)); {
                pItem->SetItemData((DWORD_PTR)pColumn);
                if (bRed) {
                    pItem->SetTextColor(RGB(255,0,0));
                }
            }			

			// type
			CString strDataType(_T(""));
			switch(pColumn->DataType())
			{
			case KEMIODataTypeInteger : strDataType = DATATYPESTRING_INTEGER; break;
			case KEMIODataTypeDouble  : strDataType = DATATYPESTRING_DOUBLE;  break;
			case KEMIODataTypeString  : strDataType = DATATYPESTRING_STRING;  break;
			}
			pRecord->AddItem(new CXTPReportRecordItemText(strDataType));

// 			// Primary key
// 			CString strPK = (pColumn->PrimaryKey() == true ? _T("Y") : _T(""));
// 			pItem = pRecord->AddItem(new CXTPReportRecordItemText(strPK));

			if (TRUE == bAutoGenerateKey) {
				if (strColNm.CompareNoCase(COLUMN_LINK_ID) == 0 || strColNm.CompareNoCase(COLUMN_TURN_ID) == 0) {
					pRecord->AddItem(new KColumnReportRecordItem(1));
					pRecord->SetVisible(FALSE);
					continue;
				}
			}

			// column
			if(m_ColumnRow.end() == itCSVColumn) {
				pRecord->AddItem(new KColumnReportRecordItem(0));
			} else {
				pRecord->AddItem(new KColumnReportRecordItem(++nCSVIndex));
				++itCSVColumn;
			}
		}

		m_ctrlReportColumn.GetReportHeader()->AllowColumnRemove( FALSE );
		m_ctrlReportColumn.FocusSubItems( TRUE );
		m_ctrlReportColumn.Populate();
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}

	TxLogDebugEndMsg();
}

void KDlgImportTurn::InitializePreview( void )
{
	TxLogDebugStartMsg();

	try
	{
		m_ctrlReportPreview.ResetContent();
		m_ctrlReportPreview.GetColumns()->Clear();
		m_ctrlReportPreview.Populate();

		bool bAutoSize(false); {
			if (m_ColumnRow.size() < 10)
				bAutoSize = true;
		}

		if (!bAutoSize) {
			QBicReportCtrlSetting::AutoColumnSizeFalse(m_ctrlReportPreview);
		} else {
			m_ctrlReportPreview.GetReportHeader()->SetAutoColumnSizing(TRUE);
		}

		CXTPReportColumn* pColumn = NULL;	

		int nColumnIndex(0);
		std::vector< CString >::iterator itColumnArray = m_ColumnRow.begin();
		while( m_ColumnRow.end() != itColumnArray )	{
			pColumn = m_ctrlReportPreview.AddColumn(new CXTPReportColumn(nColumnIndex,      (*itColumnArray), 100));
			pColumn->SetHeaderAlignment(DT_CENTER);
			if (!bAutoSize)
				pColumn->SetBestFitMode(xtpColumnBestFitModeAllData);

			++nColumnIndex;
			++itColumnArray;
		}

		CXTPReportRecord*      pRecord = nullptr;
		CXTPReportRecordItem*  pItem   = nullptr;

		int nRow(0);
		std::vector<CSVRow>::iterator itRows, itRowsEnd = m_Rows.end();
		for(itRows = m_Rows.begin(); itRows != itRowsEnd; ++itRows) {
			pRecord = m_ctrlReportPreview.AddRecord(new CXTPReportRecord());

			CSVRow& row = (*itRows);
			CSVRow::iterator itrow, itrowEnd = row.end();
			for(itrow = row.begin(); itrow != itrowEnd; ++itrow) {
				pItem   = pRecord->AddItem(new CXTPReportRecordItemText(*itrow));
				pItem->SetAlignment(DT_CENTER);
			}

			int nSizeRowData = (int)row.size();
			if (nColumnIndex > nSizeRowData) {
				for (int i= 0; i< (nColumnIndex - nSizeRowData); i++) {
					pItem   = pRecord->AddItem(new CXTPReportRecordItem);
				}
			}

			++nRow;
		}

		m_ctrlReportPreview.Populate();

		CXTPReportHeader*  pHeader        = m_ctrlReportPreview.GetReportHeader();
		CXTPReportColumns* pReportColumns = m_ctrlReportPreview.GetColumns();
		int                nReportColumns = pReportColumns->GetCount();
		for (int i= 0; i< nReportColumns; i++) {
			CXTPReportColumn* pReportColumn = pReportColumns->GetAt(i);
			if (!bAutoSize)
				pHeader->BestFit(pReportColumn);
		}
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}

	TxLogDebugEndMsg();
}

int KDlgImportTurn::GetSelectedEncoding()
{
	int nEncoding; {
		if (m_cboEncoding.GetCurSel() == 1)
			nEncoding = KEMCSVEncodingUTF8;
		else 
			nEncoding = KEMCSVEncodingANSI;
	}

	return nEncoding;
}

TCHAR KDlgImportTurn::GetSelectedSeparator()
{
	TCHAR tcSeparator; {
		int nCurSel = m_cboSeparator.GetCurSel();
		int nCode   = (int)m_cboSeparator.GetItemData(nCurSel);

		auto itFind = m_mapSeparator.find(nCode);
		if (itFind != m_mapSeparator.end()) {
			TSeparator &oTSeparator = itFind->second;
			tcSeparator = oTSeparator.tcSeparator;
		}
	}	

	return tcSeparator;
}

bool KDlgImportTurn::PriviewLoadCSV( void )
{
	TxLogDebugStartMsg();
	m_Rows.clear();

	m_ColumnRow.clear();

	TCHAR tcSeparator = GetSelectedSeparator();
	int   nEncoding   = GetSelectedEncoding();
	bool  bContainsColumn(false); {
		if (IsDlgButtonChecked(IDC_CHECK1) == BST_CHECKED)
			bContainsColumn = true;
	}
	CString strFile(_T("")); {
		m_editFile.GetWindowText( strFile );
	}

	try
	{
		QBicTxtReader oReader; {
			oReader.SetEncoding(nEncoding);
			if (oReader.Open(strFile) == false) {
				throw 2;
			}
		}

		CString strLine(_T(""));
		oReader.ReadLine(strLine);
		if( true == bContainsColumn ) {
			ParseCSVLineString( strLine, tcSeparator, m_ColumnRow );
		} else {
			int nIndex(1);
			CSVRow row;

			ParseCSVLineString( strLine, tcSeparator, row );

			CString strColumnName(_T(""));
			CSVRow::iterator itRow = row.begin(); 
			while( row.end() != itRow )	{
				strColumnName.Format( _T("Column %d"), nIndex++ );
				m_ColumnRow.push_back( strColumnName );
				++itRow;
			}

			m_Rows.push_back( row );
		}
 
		int nLoopCount = 0;

		while(oReader.ReadLine(strLine) && nLoopCount < 5000) {
			++nLoopCount;

			if ((strLine.Trim()).CompareNoCase(_T("")) == 0)
				continue;

			if (nLoopCount < 100 || nLoopCount % 5 == 0) {
				CSVRow row;
				ParseCSVLineString( strLine, tcSeparator, row );
				m_Rows.push_back( row );
			}		
		}

		oReader.Close();
	} catch (int& ex) {
		CString strError(_T(""));
		if (ex == 2)
			strError.Format(_T("Error - Open File: %s"), strFile);
		else
			strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		return false;
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		return false;
	} catch (...) {
		TxLogDebugException();
		return false;
	}

	return true;

	TxLogDebugEndMsg();
}

void KDlgImportTurn::ParseCSVLineString( CString& strLine, TCHAR tcSeparator, CSVRow& row )
{
	bool bQuote(false);
	int  nSub(0);
	CString strRow, strQuote;

	while( AfxExtractSubString( strRow, strLine, nSub++, tcSeparator ) == TRUE )
	{
		if( true == bQuote ) {
			strQuote += strRow;
			if( strRow.GetAt( strRow.GetLength() - 1 ) == _T('"') ) {
				strQuote.Remove( _T('"') );
				strRow   = strQuote;
				bQuote   = false;
				strQuote = _T("");
				row.push_back(strRow);
			}
		} else {
			TCHAR chFirst, chLast;
			if( strRow.IsEmpty() == TRUE ) {
				row.push_back( strRow );
			} else if( strRow.GetLength() == 1 ) {
				chFirst = strRow.GetAt( 0 );
				if( chFirst == _T('"') ) {
					bQuote = true;
				} else {
					row.push_back(strRow);
				}
			} else {
				chFirst = strRow.GetAt( 0 );
				chLast  = strRow.GetAt( strRow.GetLength() - 1 );

				if( (chFirst == _T('"')) && (chLast == _T('"')) ) {
					strRow.Remove( _T('"') );
					row.push_back( strRow );
				} else if( chFirst == _T('"') ) {
					bQuote = true;
					strQuote = strRow;
				} else {
					row.push_back( strRow );
				}
			}
		}
	}
}

void KDlgImportTurn::OnBnClickedCancel()
{
	KWhiteDlgEx::OnCancel();
}

void KDlgImportTurn::OnReportRecordsDropped(NMHDR *pNotifyStruct, LRESULT *pResult)
{
	XTP_NM_REPORTDRAGDROP *pItemNotify = reinterpret_cast<XTP_NM_REPORTDRAGDROP *>(pNotifyStruct);
	try
	{
		CXTPReportRecords* pRecords = pItemNotify->pRecords;
		int nCount = pRecords->GetCount();
		if (nCount < 1)	{
			return;
		}

		CXTPReportRecord*  pDropRecord    = pRecords->GetAt(0);
		CXTPReportRecords* pTargetRecords = m_ctrlReportColumn.GetRecords();

		if (nullptr != pDropRecord)	{
			int                   nRowIndex = pDropRecord->GetIndex(); // will be Drop Row's Index
			CXTPReportRecordItem* pItem2    = pDropRecord->GetItem(0);
			int nComboIndex                 = (int)pItem2->GetItemData();

			pTargetRecords->RemoveRecord(pDropRecord);
			m_ctrlReportColumn.Populate();

			pTargetRecords = m_ctrlReportColumn.GetRecords();
			CXTPReportRecord* pTargetRecord = pTargetRecords->GetAt(nRowIndex); // pItemNotify->pTargetRecord 사용 불가

			if (nullptr != pTargetRecord) {
				KColumnReportRecordItem* pItem = (KColumnReportRecordItem*)pTargetRecord->GetItem(_2_COLUMN_IMPORTFIELD_NAME);
				pItem->m_nIndex = nComboIndex;
				//m_ctrlReportColumn.RedrawControl();

				CXTPReportRow* pRow = m_ctrlReportColumn.GetRows()->Find(pTargetRecord);
				m_ctrlReportColumn.SetFocusedRow(pRow);
			}
		}
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::OnReportDropSampleColumn(NMHDR *pNotifyStruct, LRESULT *pResult)
{
	try
	{
		XTP_NM_REPORTDRAGDROP *pItemNotify = reinterpret_cast<XTP_NM_REPORTDRAGDROP *>(pNotifyStruct);

		CXTPReportRecords* pRecords = pItemNotify->pRecords;
		int nCount       = pRecords->GetCount();

		for (int i= 0; i< nCount; i++) {
			CXTPReportRecord* pRecord = pRecords->GetAt(i);
			m_ctrlReportSampleColumn.RemoveRecordEx(pRecord);
		}
		m_ctrlReportSampleColumn.Populate();
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::OnBnClickedCheckDefault()
{
	ControlDefaultCheck();
}

void KDlgImportTurn::ControlDefaultCheck()
{
	try 
	{
		if (IsDlgButtonChecked(IDC_CHECK4) == BST_CHECKED)
			UpdateColumnView();
		else
			AllNullCheck();
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::AllNullCheck()
{
	try 
	{
		CXTPReportRecords* pRecords = m_ctrlReportColumn.GetRecords();
		int nRecordCount = pRecords->GetCount();

		for (int i = 0; i < nRecordCount; ++i) {
			CXTPReportRecord* pRecord = pRecords->GetAt(i);
			if (FALSE == pRecord->IsVisible())
				continue;

			KColumnReportRecordItem* pItem   = (KColumnReportRecordItem*)pRecord->GetItem(_2_COLUMN_IMPORTFIELD_NAME);
			pItem->m_nIndex = 0;
		}

		m_ctrlReportColumn.RedrawControl();
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::OnBnClickedOk()
{
	UpdateData( TRUE );

	try
	{
		m_nStartNum        = GetDlgItemInt(IDC_EDIT1);
		m_bAutoGenerateKey = IsAutoGenerateKey();
		if ( m_bAutoGenerateKey == TRUE && m_nStartNum <= 0) {
			//AfxMessageBox(_T("시작 ID값은 0이 될 수 없습니다."));
			if (KmzSystem::GetLanguage() == KEMKorea) {
				AfxMessageBox(_T("시작 ID값은 0이 될 수 없습니다."));
			}
			else {
				AfxMessageBox(_T("The start ID value cannot be zero."));
			}
			return;
		}

		KEMImportType emImportType = GetSelectedImportType();

		ValidateImport();

		if( false == AlertTableChange() ) 
			return;

		ThreadPara oPara(this);

		// 2019.06.11 Progress 다이얼로그 언어설정 관련 수정
		int nLang = 1;
		if (KmzSystem::GetLanguage() == KEMKorea)
		{
			nLang = 0;
		}

		if (true) { // 데이터 검증 및 중간 바이너리 작성
			oPara.TBusiness  = 0;
			oPara.TKeyInt32[0] = 0;      // 레코드 개수 저장
			oPara.TKeyInt32[1] = 0;      // Success 개수 저장
			oPara.TKeyInt32[2] = 0;      // 실패 개수 저장

			RThreadInfo.Init();
			QBicSimpleProgressThread::ExecuteThread(ThreadRun, &oPara, false, nLang); 

			if (RThreadInfo.IsOK() == false) {
				ThrowException(RThreadInfo.ErrorMsg());
			} else {
				CString strMsg(_T(""));
				GetStatisticsMsg(emImportType, &oPara, strMsg);
				if (AfxMessageBox(strMsg, MB_YESNO) == IDNO)
					return;
			}
		}

		if (true) { // Read 중간바이너리 & DB Import
			oPara.TBusiness = 1; // oPara.TKeyInt[0]에 레코드 개수가 저장된 상태에서 넘어감

			RThreadInfo.Init();
			QBicSimpleProgressThread::ExecuteThread(ThreadRun, &oPara, false, nLang); 

			if (RThreadInfo.IsOK() == false) {
				ThrowException(RThreadInfo.ErrorMsg());
			}
		}

		/* 노드테이블 이나 링크테이블의 Insert, Add 인경우 
		   MapView에 대한 처리가 필요하다면, 하단에 */
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("오류 : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		AfxMessageBox(strError);

		return;
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		AfxMessageBox(ex->GetErrorMessage());

		return;
	} catch (...) {
		TxLogDebugException();
		//AfxMessageBox(_T("예상치 못한 오류가 발생하였습니다.\n관리자에게 문의하여 주십시오."));
		if (KmzSystem::GetLanguage() == KEMKorea) {
			AfxMessageBox(_T("예상치 못한 오류가 발생하였습니다.\n관리자에게 문의하여 주십시오."));
		}
		else {
			AfxMessageBox(_T("An unexpected error has occurred. \ nPlease contact the administrator."));
		}

		return;
	}
 
    //★ Turn Type 정리
    KDlgTurnTypeEdit oDlg(m_pTarget);
    oDlg.DoModal();

 	RelationTableNotify();
	OnOK();
}

unsigned __stdcall KDlgImportTurn::ThreadRun( void* p )
{
	QBicSimpleProgressParameter* pParameter = (QBicSimpleProgressParameter*)p;
	if (pParameter != nullptr) {
		ThreadPara* pPara = (ThreadPara*)pParameter->GetParameter(); {
			KDlgImportTurn* pDlg = (KDlgImportTurn*)pPara->TWindow;

			if (0 == pPara->TBusiness)
				pDlg->Execute(pPara);
			else
				pDlg->ExecuteImport(pPara);
		}
	}

	return 1;
}

void KDlgImportTurn::Execute(ThreadPara* pPara)
{
	try 
	{
		KDBaseImportTable::NodeRecord(m_pTable, m_mapNodeRecord);
		KDBaseImportTable::LinkRecordODBase(m_pTable, m_mapLinkRecord);
		KDBaseImportTable::LinkRecord(m_pTable, m_setLinkID);
		KDBaseImportTable::LinkRecordLinkBase(m_pTable, m_mapLinkBasedRecord);

		if (KmzSystem::GetLanguage() == KEMKorea) {
			AddStatusMessage(_T("파일을 불러오는 중..."));
		}
		else {
			AddStatusMessage(_T("Reading File..."));
		}

		//Convert CSV to Binary
		ReadCSVFile(pPara);
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		RThreadInfo.SetErrorFlag(-1, strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		RThreadInfo.SetErrorFlag(-1, ex->GetErrorMessage());
	} catch (...) {
		TxLogDebugException();
		//RThreadInfo.SetErrorFlag(-1, _T("오류가 발생하였습니다."));
		if (KmzSystem::GetLanguage() == KEMKorea) {
			RThreadInfo.SetErrorFlag(-1, _T("오류가 발생하였습니다."));
		}
		else {
			RThreadInfo.SetErrorFlag(-1, _T("Error occured !"));
		}
	}
}

void KDlgImportTurn::ExecuteImport(ThreadPara* pPara)
{
	try 
	{
		KEMImportType emImportType = GetSelectedImportType();
		if (KEMImportInsert == emImportType)
			ImportTurnData(pPara);
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		RThreadInfo.SetErrorFlag(-1, strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		RThreadInfo.SetErrorFlag(-1, ex->GetErrorMessage());
	} catch (...) {
		TxLogDebugException();
		//RThreadInfo.SetErrorFlag(-1, _T("오류가 발생하였습니다."));
		if (KmzSystem::GetLanguage() == KEMKorea) {
			RThreadInfo.SetErrorFlag(-1, _T("오류가 발생하였습니다."));
		}
		else {
			RThreadInfo.SetErrorFlag(-1, _T("Error occured !"));
		}
	}
}

void KDlgImportTurn::GetStatisticsMsg(KEMImportType a_emImportType, ThreadPara* pPara, CString &a_strMsg)
{
	a_strMsg = _T("");
	try 
	{
		if (KEMImportInsert == a_emImportType) {
			if (KmzSystem::GetLanguage() == KEMKorea) {
				if (KImportCommon::IsEmptyTable(m_pTarget, TABLE_TURN) == false) { // true: 데이터무, false : 데이터 존재
					a_strMsg.Format(_T("Insert 수행시 %s 테이블의 기존 데이터가 삭제되며,\r\n"));
				}

				a_strMsg.Append(_T("입력된 데이터의 내역은 아래와 같습니다.\r\n"));
				a_strMsg.AppendFormat(_T("#1. 레코드 개수: %d 건\r\n"), pPara->TKeyInt32[0]);
			}
			else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
				if (KImportCommon::IsEmptyTable(m_pTarget, TABLE_TURN) == false) { // true: 데이터무, false : 데이터 존재
					a_strMsg = (_T("WARNING : Existing data would be delete,\r\n"));
				}

				a_strMsg.Append(_T("Imported data are as follows.\r\n"));
				a_strMsg.AppendFormat(_T("#1. Total number of records : %d\r\n"), pPara->TKeyInt32[0]);
			}
			
		}

		//a_strMsg.Append(_T("\n진행 하시겠습니까?\r\n"));
		if (KmzSystem::GetLanguage() == KEMKorea) {
			a_strMsg.Append(_T("\n진행 하시겠습니까?\r\n"));
		}
		else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
			a_strMsg.Append(_T("\nDo you want to continue?\r\n"));
		}
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::ReadCSVFile(ThreadPara* pPara)
{
	TxLogDebugStartMsg();

	TCHAR tcSeparator = GetSelectedSeparator();
	int   nEncoding   = GetSelectedEncoding();
	bool  bContainsColumn(false); {
		if (IsDlgButtonChecked(IDC_CHECK1) == BST_CHECKED)
			bContainsColumn = true;
	}
	CString strFile(_T("")); {
		m_editFile.GetWindowText( strFile );
	}
	
	QBicTxtReader oReader; {
		oReader.SetEncoding(nEncoding);
		if (oReader.Open(strFile) == false)
			return;
	}

	QBicFile::DeleteFile(m_strMiddleFile);
	std::ofstream ofs(m_strMiddleFile, std::ios::binary);
	
	QBicFile::DeleteFile(m_strErrFile);
	QBicTxtWriter ofErr; {
		if (ofErr.Open(m_strErrFile) == false)
			return;
	}

	std::vector<TColMatch> vecColMatch; { // 저장필드와 입력파일의 필드idx 매칭정보 저장(Re)
#pragma region Load vecColMatch
		try 
		{
			CXTPReportRecords* pRecords = m_ctrlReportColumn.GetRecords();
			int nRecordCount = pRecords->GetCount();
			for (int i= 0; i< nRecordCount; i++) {
				CXTPReportRecord* pRecord            = pRecords->GetAt(i);
				int               nImportColumnIndex = GetImportColumnIndex(pRecord);
				if (0 == nImportColumnIndex || pRecord->IsVisible() == FALSE)
					continue;

				KIOColumn*        pIOColumn	        = GetDefIOColumn(pRecord);

				TColMatch oTColMatch;
				oTColMatch.pIOColumn       = pIOColumn;
				oTColMatch.nImportColIndex = nImportColumnIndex;

				vecColMatch.push_back(oTColMatch);
			}
		} catch (int& ex) {
			CString strError(_T(""));
			strError.Format(_T("Error : %d"), ex);
			TxLogDebug((LPCTSTR)strError);
		} catch (KExceptionPtr ex) {
			TxExceptionPrint(ex);
		} catch (...) {
			TxLogDebugException();
		}
	}
#pragma endregion Load vecColMatch

	int nSuccessCnt(0);
	int nFailedCnt(0);
	int nImportDataCount(0);
	int nCurrentLine(0);
	
	try
	{
		CString strReadLine(_T(""));
		bool    bEverErrLine(false);

		//CSV파일 헤더 존재 시 고의적으로 한줄 읽어서 버림.
		if( true == bContainsColumn ) {
			oReader.ReadLine(strReadLine);
			++nCurrentLine;
		}

		KEMImportType emImportType  = GetSelectedImportType();
		int           nBaseDataType = GetBaseDataType();

		m_setPrimaryID.clear();
		m_setUpdateTransitLineID.clear();

		while( oReader.ReadLine(strReadLine) ) {
			++nCurrentLine;

			if ((strReadLine.Trim()).CompareNoCase(_T("")) == 0) {
				CString strErrorMsg(_T("")); {
					//strErrorMsg.Format(_T("Line : %d =>\t 데이터 없음\r\n"), nCurrentLine);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\t 데이터 없음\r\n"), nCurrentLine);
					}
					else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\t There is no any data\r\n"), nCurrentLine);
					}
				}
				ofErr.Write(strErrorMsg);
				continue;
			}

			CSVRow row;
			ParseCSVLineString( strReadLine, tcSeparator, row );

			if (KEMBaseLink == nBaseDataType) {
				CSV2BinaryTurn(vecColMatch, nCurrentLine, bEverErrLine, row, ofs, ofErr);
			} else {
				CSV2BinaryTurnNode(vecColMatch, nCurrentLine, bEverErrLine, row, ofs, ofErr);
			}
		}

		if(bEverErrLine) {
			CString strErrorMsg(_T(""));
			//strErrorMsg.Format(_T("Import 실패\r\n %s 파일에서 내역을 확인 하세요."), IMPORT_ERROR_FILE_NAME);
			if (KmzSystem::GetLanguage() == KEMKorea) {
				strErrorMsg.Format(_T("Import 실패\r\n %s 파일에서 내역을 확인 하세요."), IMPORT_ERROR_FILE_NAME);
			}
			else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
				strErrorMsg.Format(_T("Import failed !\r\n Check the details from the %s."), IMPORT_ERROR_FILE_NAME);
			}
			ErrorFileOpen();
			ThrowException(strErrorMsg);
		} 
 
		nImportDataCount = nCurrentLine;
		if( bContainsColumn )	{
			--nImportDataCount;
		}
		pPara->TKeyInt32[0] = nImportDataCount;      // 레코드 개수 저장
		pPara->TKeyInt32[1] = nSuccessCnt;           // Update/Add Mode일 경우 성공 데이터의 개수
		pPara->TKeyInt32[2] = nFailedCnt;            // Update/Add Mode일 경우 실패 데이터의 개수

		ofs.close();
		oReader.Close();
		ofErr.Close();
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		ofs.close();
		oReader.Close();
		ofErr.Close();
		throw ex;
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		ofs.close();
		oReader.Close();
		ofErr.Close();
		ThrowException(ex->GetErrorMessage());
	} catch (...) {
		TxLogDebugException();
		ofs.close();
		oReader.Close();
		ofErr.Close();
		throw 9;
	}
	
	TxLogDebugEndMsg();
}

void KDlgImportTurn::CSV2BinaryTurn(std::vector<TColMatch> &a_vecColMatch, int a_nCurrentLine, bool& a_bEverErrLine, CSVRow &a_row,  std::ofstream& ofs,  QBicTxtWriter& ofErr)
{
	CString strIOColumnName(_T(""));
	CString strImportValue(_T(""));
	Integer nxValue(0);

	try 
	{
		Integer nxAtNodeID(0);
		Integer nxFLinkID(0);
		Integer nxTLinkID(0);

		CString strErrorMsg(_T(""));

		int nSizeVec = (int)a_vecColMatch.size();
		for (int i= 0; i< nSizeVec; i++) {
			TColMatch         &oTColMatch = a_vecColMatch[i];

			const KIOColumn*  pIOColumn   = oTColMatch.pIOColumn;
			KEMIODataType     emDataType  = pIOColumn->DataType();
			strIOColumnName               = pIOColumn->Name();

			if( a_row.size() > (size_t)(oTColMatch.nImportColIndex -1) ) 
				strImportValue = a_row[oTColMatch.nImportColIndex -1];
			else
				strImportValue = _T("");

			if (strIOColumnName.CompareNoCase(COLUMN_TURN_ID) == 0 )	{
				Integer nxTurnID = _ttoi64(strImportValue);
				if (CheckPrimaryKey(nxTurnID)) {
					a_bEverErrLine = true;
					//strErrorMsg.Format(_T("Line : %d =>\t Primar Key 중복 ID = %I64d"), a_nCurrentLine, nxTurnID);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\t Primar Key 중복 ID = %I64d"), a_nCurrentLine, nxTurnID);
					}
					else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\t Duplicated Primar Key %I64d exist"), a_nCurrentLine, nxTurnID);
					}
					ofErr.Write(strErrorMsg);
				}
			} else if (strIOColumnName.CompareNoCase(COLUMN_TURN_NODE) == 0) {
				nxAtNodeID = _ttoi64(strImportValue);
				if (CheckNodeData(nxAtNodeID)) {
					a_bEverErrLine = true;
					//strErrorMsg.Format(_T("Line : %d =>\tNode 테이블에 존재하지 않는 Node_ID : %I64d"), a_nCurrentLine, nxAtNodeID);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\tNode 테이블에 존재하지 않는 Node_ID : %I64d"), a_nCurrentLine, nxAtNodeID);
					}
					else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\tThe Node ID %I64d does NOT exist in Node Table"), a_nCurrentLine, nxAtNodeID);
					}
					ofErr.Write(strErrorMsg);
				}
			} else if (strIOColumnName.CompareNoCase(COLUMN_TURN_F_LINK) == 0) {
				nxFLinkID = _ttoi64(strImportValue);
				if( CheckLinkData(nxFLinkID) ) {
					a_bEverErrLine = true;
					//strErrorMsg.Format(_T("Line : %d =>\tLink 테이블에 존재하지 않는 Link_ID = %I64d"), a_nCurrentLine, nxFLinkID);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\tLink 테이블에 존재하지 않는 Link_ID = %I64d"), a_nCurrentLine, nxFLinkID);
					}
					else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\tThe Link ID %I64d does NOT exist in Link Table"), a_nCurrentLine, nxFLinkID);
					}
					ofErr.Write(strErrorMsg);
				}
			} else if (strIOColumnName.CompareNoCase(COLUMN_TURN_T_LINK) == 0) {
				nxTLinkID = _ttoi64(strImportValue);
				if( CheckLinkData(nxTLinkID) ) {
					a_bEverErrLine = true;
					//strErrorMsg.Format(_T("Line : %d =>\tLink 테이블에 존재하지 않는 Link_ID = %I64d"), a_nCurrentLine, nxTLinkID);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\tLink 테이블에 존재하지 않는 Link_ID = %I64d"), a_nCurrentLine, nxTLinkID);
					}
					else { //if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\tThe Link ID %I64d does NOT exist in Link Table"), a_nCurrentLine, nxTLinkID);
					}
					ofErr.Write(strErrorMsg);
				}
			} 
		}

		if (CheckLinkBasedLinkData(nxFLinkID, nxAtNodeID, nxTLinkID, strErrorMsg)) {
			a_bEverErrLine = true;
			CString strTempMsg(_T(""));
			strTempMsg.Format(_T("Line : %d =>\t%s"), a_nCurrentLine, strErrorMsg);
			ofErr.Write(strTempMsg);
		}

		if(false == a_bEverErrLine) {
			CString strImportValue(_T(""));
			CString strColumnName (_T(""));

			int nSizeVec = (int)a_vecColMatch.size();
			for (int i= 0; i< nSizeVec; i++) {
				TColMatch         &oTColMatch = a_vecColMatch[i];

				const KIOColumn*  pIOColumn   = oTColMatch.pIOColumn;
				KEMIODataType     emDataType  = pIOColumn->DataType();
				strColumnName			      = pIOColumn->Name();

				if( a_row.size() > (size_t)(oTColMatch.nImportColIndex -1) ) 
					strImportValue = a_row[oTColMatch.nImportColIndex -1];
				else
					strImportValue = _T("");

				if(false == a_bEverErrLine)
					WriteOutputStream(strImportValue, emDataType, ofs);
			}
		}
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		ThrowException(_T("Failed to Create Binary Data..."));
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		ThrowException(ex->GetErrorMessage());
	} catch (...) {
		TxLogDebugException();
		ThrowException(_T("Failed to Create Binary Data..."));
	}
}

void KDlgImportTurn::CSV2BinaryTurnNode(std::vector<TColMatch> &a_vecColMatch, int a_nCurrentLine, bool& a_bEverErrLine, CSVRow &a_row,  std::ofstream& ofs,  QBicTxtWriter& ofErr)
{
	CString strIOColumnName(_T(""));
	CString strImportValue(_T(""));
	Integer nxValue(0);

	try 
	{
		Integer nxAtNodeID(0);
		Integer nxFNodeID(0);
		Integer nxTNodeID(0);

		std::map<int, CString> mapCSVData;
		int		nFNodeLocation(0);
		int		nTNodeLocation(0);

		CString strErrorMsg(_T(""));

		int nSizeVec = (int)a_vecColMatch.size();
		for (int i= 0; i< nSizeVec; i++) {
			TColMatch         &oTColMatch = a_vecColMatch[i];

			const KIOColumn*  pIOColumn   = oTColMatch.pIOColumn;
			KEMIODataType     emDataType  = pIOColumn->DataType();
			strIOColumnName               = pIOColumn->Name();

			if( a_row.size() > (size_t)(oTColMatch.nImportColIndex -1) ) 
				strImportValue = a_row[oTColMatch.nImportColIndex -1];
			else
				strImportValue = _T("");

			if (strIOColumnName.CompareNoCase(COLUMN_TURN_ID) == 0 )	{
				Integer nxTurnID = _ttoi64(strImportValue);
				if (CheckPrimaryKey(nxTurnID)) {
					a_bEverErrLine = true;
					//strErrorMsg.Format(_T("Line : %d =>\t Primar Key 중복 ID = %I64d"), a_nCurrentLine, nxTurnID);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\t Primar Key 중복 ID = %I64d"), a_nCurrentLine, nxTurnID);
					}
					else { //if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\t Duplicated Primar Key %I64d exist"), a_nCurrentLine, nxTurnID);
					}
					ofErr.Write(strErrorMsg);
				}
			} else if (strIOColumnName.CompareNoCase(COLUMN_TURN_NODE) == 0) {
				nxAtNodeID = _ttoi64(strImportValue);
				if (CheckNodeData(nxAtNodeID)) {
					a_bEverErrLine = true;
					//strErrorMsg.Format(_T("Line : %d =>\tNode 테이블에 존재하지 않는 Node_ID : %I64d"), a_nCurrentLine, nxAtNodeID);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\tNode 테이블에 존재하지 않는 Node_ID : %I64d"), a_nCurrentLine, nxAtNodeID);
					}
					else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\tThe Node ID %I64d does NOT exist in Node Table"), a_nCurrentLine, nxAtNodeID);
					}
					ofErr.Write(strErrorMsg);
				}
			} else if (strIOColumnName.CompareNoCase(COLUMN_TURN_F_LINK) == 0) { // Node Base 에서는 FNode
				nxFNodeID = _ttoi64(strImportValue);
				nFNodeLocation = i;

				if( CheckNodeData(nxFNodeID) ) {
					a_bEverErrLine = true;
					//strErrorMsg.Format(_T("Line : %d =>\tNode 테이블에 존재하지 않는 Node_ID : %I64d"), a_nCurrentLine, nxFNodeID);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\tNode 테이블에 존재하지 않는 Node_ID : %I64d"), a_nCurrentLine, nxFNodeID);
					}
					else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\tThe Node ID %I64d does NOT exist in Node Table"), a_nCurrentLine, nxFNodeID);
					}
					ofErr.Write(strErrorMsg);
				}
			} else if (strIOColumnName.CompareNoCase(COLUMN_TURN_T_LINK) == 0) { // Node Base 에서는 TNode
				nxTNodeID = _ttoi64(strImportValue);
				nTNodeLocation = i;

				if( CheckNodeData(nxTNodeID) ) {
					a_bEverErrLine = true;
					//strErrorMsg.Format(_T("Line : %d =>\tNode 테이블에 존재하지 않는 Node_ID : %I64d"), a_nCurrentLine, nxTNodeID);
					if (KmzSystem::GetLanguage() == KEMKorea) {
						strErrorMsg.Format(_T("Line : %d =>\tNode 테이블에 존재하지 않는 Node_ID : %I64d"), a_nCurrentLine, nxTNodeID);
					}
					else { //if (KmzSystem::GetLanguage() == KEMEnglish) {
						strErrorMsg.Format(_T("Line : %d =>\tThe Node ID %I64d does NOT exist in Node Table"), a_nCurrentLine, nxTNodeID);
					}
					ofErr.Write(strErrorMsg);
				}
			}

			mapCSVData.insert(std::make_pair(i, strImportValue));
		}

		// FNode, TNode 정보를 입력하여, FLinkID 와 TLinkID를 얻어낸다.
		Integer nxFLinkID(0);
		Integer nxTLinkID(0);
		if (CheckNodetoLinkData(nxFNodeID, nxAtNodeID, nxTNodeID, OUT strErrorMsg, nxFLinkID, nxTLinkID)) {
			a_bEverErrLine = true;
			CString strTempMsg(_T(""));
			strTempMsg.Format(_T("Line : %d =>\t%s"), a_nCurrentLine, strErrorMsg);
			ofErr.Write(strTempMsg);
		}

		CString strFLinkID(_T(""));
		CString strTLinkID(_T("")); {
			strFLinkID.Format(_T("%I64d"), nxFLinkID);
			strTLinkID.Format(_T("%I64d"), nxTLinkID);
		}
		mapCSVData[nFNodeLocation] = strFLinkID; // FLink 값으로 재 저장한다.
		mapCSVData[nTNodeLocation] = strTLinkID; // TLink 값으로 재 저장한다.

		if(false == a_bEverErrLine) {
			CString strColumnName (_T(""));

			int nSizeVec = (int)a_vecColMatch.size();
			for (int i= 0; i< nSizeVec; i++) {
				TColMatch         &oTColMatch = a_vecColMatch[i];

				const KIOColumn*  pIOColumn   = oTColMatch.pIOColumn;
				KEMIODataType     emDataType  = pIOColumn->DataType();

				CString strImportValue(_T(""));
				auto iterFind   = mapCSVData.find(i);
				if (iterFind != mapCSVData.end()) {
					strImportValue = iterFind->second;
				}

				if(false == a_bEverErrLine)
					WriteOutputStream(strImportValue, emDataType, ofs);
			}
		}
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		ThrowException(_T("Failed to Create Binary Data..."));
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		ThrowException(ex->GetErrorMessage());
	} catch (...) {
		TxLogDebugException();
		ThrowException(_T("Failed to Create Binary Data..."));
	}
}

bool KDlgImportTurn::CheckLinkData(Integer a_nxLinkID)
{
	if (m_setLinkID.find(a_nxLinkID) == m_setLinkID.end()) {
		return true;
	}
	
	return false;
}

bool KDlgImportTurn::CheckNodeData(Integer a_nxNodeID)
{
	if(m_mapNodeRecord.find(a_nxNodeID) == m_mapNodeRecord.end()) {
		return true;
	}

	return false;
}

bool KDlgImportTurn::CheckLinkBasedLinkData(Integer nxFLinkID, Integer nxAtNodeID, Integer nxTLinkID, CString &a_strErrMsg)
{
	auto itFind = m_mapLinkBasedRecord.find(nxFLinkID);
	if (itFind == m_mapLinkBasedRecord.end()) {
		//a_strErrMsg.Format(_T("Link 테이블에 존재하지 않는 FLink : F_LinkID = %I64d"), nxFLinkID);
		if (KmzSystem::GetLanguage() == KEMKorea) {
			a_strErrMsg.Format(_T("Link 테이블에 존재하지 않는 FLink : F_LinkID = %I64d"), nxFLinkID);
		}
		else { //if (KmzSystem::GetLanguage() == KEMEnglish) {
			a_strErrMsg.Format(_T("The FromLink ID %I64d does NOT exist in Link Table"), nxFLinkID);
		}
		return true;
	} else {
		KODKey oODKey = itFind->second;
		if (oODKey.DestinationID != nxAtNodeID) {
			//a_strErrMsg = _T("시작 Link와 At Node 정보 불일치");
			if (KmzSystem::GetLanguage() == KEMKorea) {
				a_strErrMsg = _T("시작 Link와 At Node 정보 불일치");
			}
			else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
				a_strErrMsg = _T("FromLink does NOT match with At Node.");
			}
			return true;
		}
	}

	itFind = m_mapLinkBasedRecord.find(nxTLinkID);
	if (itFind == m_mapLinkBasedRecord.end()) {
		//a_strErrMsg.Format(_T("Link 테이블에 존재하지 않는 TLink : T_LinkID = %I64d"), nxTLinkID);
		if (KmzSystem::GetLanguage() == KEMKorea) {
			a_strErrMsg.Format(_T("Link 테이블에 존재하지 않는 FLink : T_LinkID = %I64d"), nxTLinkID);
		}
		else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
			a_strErrMsg.Format(_T("The ToLink ID %I64d does NOT exist in Link Table"), nxTLinkID);
		}
		return true;
	} else {
		KODKey oODKey = itFind->second;
		if (nxAtNodeID != oODKey.OriginID)
		{
			//a_strErrMsg = _T("Line : %d =>\tAt Node와 종료 Link 정보 불일치");
			if (KmzSystem::GetLanguage() == KEMKorea) {
				a_strErrMsg = _T("Line : %d =>\tAt Node와 종료 Link 정보 불일치");
			}
			else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
				a_strErrMsg = _T("Line : %d =>\tToLink does NOT match with At Node.");
			}
			return true;
		}
	}

	return false;
}

bool KDlgImportTurn::CheckNodetoLinkData(Integer a_nxFNodeID, Integer a_nxAtNodeID, Integer a_nxTNodeID, OUT CString &a_strErrMsg, Integer &a_nxFLinkID, Integer &a_nxTLinkID)
{
	KODKey oFODKey(a_nxFNodeID, a_nxAtNodeID);
	KODKey oTODKey(a_nxAtNodeID, a_nxTNodeID);

	auto iterF   = m_mapLinkRecord.find(oFODKey);
	auto iterT   = m_mapLinkRecord.find(oTODKey);
	auto iterend = m_mapLinkRecord.end();

	if (iterF == iterend) {
		//a_strErrMsg.Format(_T("Link 테이블에 존재하지 않는 FLink : F_NodeID = %I64d, T_NodeID = %I64d"), a_nxFNodeID, a_nxAtNodeID);
		if (KmzSystem::GetLanguage() == KEMKorea) {
			a_strErrMsg.Format(_T("Link 테이블에 존재하지 않는 FLink : F_NodeID = %I64d, T_NodeID = %I64d"), a_nxFNodeID, a_nxAtNodeID);
		}
		else { //if (KmzSystem::GetLanguage() == KEMEnglish) {
			a_strErrMsg.Format(_T("The FromLink (%I64d,%I64d) does NOT exist in Link Table"), a_nxFNodeID, a_nxAtNodeID);
		}
		return true;
	} else {
		a_nxFLinkID = iterF->second;
	}

	if (iterT == iterend) {
		//a_strErrMsg.Format(_T("Link 테이블에 존재하지 않는 TLink : F_NodeID = %I64d, T_NodeID = %I64d"), a_nxAtNodeID, a_nxTNodeID);
		if (KmzSystem::GetLanguage() == KEMKorea) {
			a_strErrMsg.Format(_T("Link 테이블에 존재하지 않는 TLink : F_NodeID = %I64d, T_NodeID = %I64d"), a_nxAtNodeID, a_nxTNodeID);
		}
		else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
			a_strErrMsg.Format(_T("The ToLink (%I64d,%I64d) does NOT exist in Link Table"), a_nxAtNodeID, a_nxTNodeID);
		}
		return true;
	} else {
		a_nxTLinkID = iterT->second;
	}

	return false;
}

bool KDlgImportTurn::CheckPrimaryKey(Integer a_nxPrimaryKey)
{
	auto find = m_setPrimaryID.find(a_nxPrimaryKey);
	auto end  = m_setPrimaryID.end();

	if (find != end) { // 중복이다
		return true;
	} else	{
		m_setPrimaryID.insert(a_nxPrimaryKey);
	}

	return false;
}

#include <string>
void KDlgImportTurn::WriteOutputStream(CString a_strImportValue, KEMIODataType a_emDataType, std::ofstream& ofs)
{
	try
	{
		double	dValue  = 0.0;
		Integer nxValue = 0;

		if(a_emDataType == KEMIODataTypeDouble)	{
			dValue = _ttof(a_strImportValue);
			ofs.write(reinterpret_cast<char*>(&dValue), sizeof(double));
		} else if(a_emDataType == KEMIODataTypeInteger) {
			nxValue = _ttoi64(a_strImportValue);
			ofs.write(reinterpret_cast<char*>(&nxValue), sizeof(Integer));
		} else if(a_emDataType == KEMIODataTypeString) {
			const int STR_LENGTH = 200;
			if(a_strImportValue.GetLength() > STR_LENGTH - 1)
				a_strImportValue.Truncate(STR_LENGTH - 1);

			TCHAR     szStrOut[STR_LENGTH];

			_tcscpy_s(szStrOut, a_strImportValue);
			ofs.write( reinterpret_cast<char*>( szStrOut  ), sizeof(TCHAR) * STR_LENGTH );

			//delete  szStrOut;
		}
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);

		throw ex;
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		throw ex;
	} catch (...) {
		TxLogDebugException();
		throw 1;
	}
}

void KDlgImportTurn::ImportTurnData(ThreadPara* pPara)
{
	TxLogDebugStartMsg();

	std::ifstream ifs(m_strMiddleFile, std::ios::binary);

	int nImportDataCount = (int)pPara->TKeyInt32[0];

	CString strValue(_T(""));
	double	dValue(0.0);
	Integer	nxValue(0);

	KDBaseConPtr spDBase = m_pTarget->GetDBaseConnection();

	spDBase->BeginTransaction();

	CString strQuery(_T("")); {
		CString strTableName = m_pTable->Name();
		strQuery.Format(_T("delete from %s"), strTableName);
	}
	spDBase->ExecuteUpdate(strQuery);

	CString strPreparedQuery = GeneratePrepareQuery();
	KPreparedStatementPtr spPrepared = spDBase->PrepareStatement(strPreparedQuery);

	try
	{
		std::vector<KIOColumn*> vecIOColumn; {
			CXTPReportRecords* pRecords = m_ctrlReportColumn.GetRecords();
			int nRecordCount = pRecords->GetCount();
			for (int i= 0; i< nRecordCount; i++) {
				CXTPReportRecord* pRecord        = pRecords->GetAt(i);

				KIOColumn*        pIOColumn      = GetDefIOColumn(pRecord);
				int               nSelectedIndex = GetImportColumnIndex(pRecord);

				if (!pRecord->IsVisible())
					continue;

				if(0 < nSelectedIndex)
					vecIOColumn.push_back(pIOColumn);
			}
		}
		int nSizeCol = (int)vecIOColumn.size();

		int nloopCount(0);
		while (!ifs.eof())
		{
			if ( ++nloopCount % 500 == 0) {
				CString strMsg;
				strMsg.Format(_T("Importing data rows ( %d / %d )"), nloopCount, nImportDataCount);
				if (KmzSystem::GetLanguage() == KEMKorea) {
					strMsg.Format(_T("읽은 파일 라인수 / 총 라인수 :  %d / %d"), nloopCount, nImportDataCount);
				}
				AddStatusMessage( strMsg );
			}

			int nBindCount(1);

			if (m_bAutoGenerateKey)
				spPrepared->BindInt64(nBindCount++, m_nStartNum++);

			for (int i= 0; i< nSizeCol; i++) {
				KIOColumn*    pColumn       = vecIOColumn[i];
				KEMIODataType emDataType    = pColumn->DataType();
				CString       strColumnName = pColumn->Name();

				if(emDataType == KEMIODataTypeDouble) {
					ifs.read(reinterpret_cast<char*>(&dValue), sizeof(double));
					if(ifs.eof())
						break;

					spPrepared->BindDouble(nBindCount++, dValue);
				} else if(emDataType == KEMIODataTypeInteger) {
					ifs.read(reinterpret_cast<char*>(&nxValue), sizeof(Integer));
					if(ifs.eof())
						break;

					spPrepared->BindInt64(nBindCount++, nxValue);
				} else if(emDataType == KEMIODataTypeString) {
					const int STR_LENGTH = 200;
					TCHAR*  szStringIn = new TCHAR[STR_LENGTH];
					ifs.read( reinterpret_cast<char*>( szStringIn ), sizeof(TCHAR) * STR_LENGTH );
					if(ifs.eof())
						break;
					strValue = szStringIn;
					delete szStringIn;

					spPrepared->BindText(nBindCount++, strValue);
				}
			}

			if(ifs.eof())
				break;

			spPrepared->ExecuteUpdate();
			spPrepared->Reset();
		}

		spDBase->Commit();
		ifs.close();
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		spDBase->RollBack();
		ifs.close();
		throw 1;
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
		spDBase->RollBack();
		ifs.close();
		throw 1;
	} catch (...) {
		TxLogDebugException();
		spDBase->RollBack();
		ifs.close();
		throw 1;
	}
	TxLogDebugEndMsg();
}

CString KDlgImportTurn::GeneratePrepareQuery( void )
{
	CXTPReportRecords* pRecords = m_ctrlReportColumn.GetRecords();
	int nRecordCount = pRecords->GetCount();

	CString strPreparedQueryHeader; {
		strPreparedQueryHeader = _T(" INSERT INTO ") + m_strTableName + _T("(");
	}
	CString strPreparedQueryValues(_T(" Values("));

	int nIdx(0);
	for (int i= 0; i< nRecordCount; i++) {
		CXTPReportRecord* pRecord = pRecords->GetAt(i);

		//jyk: insert query 는 visible 체크 해서는 안됨 -> insert 에서의 visible은 오로지 AutoGerate 일때만 가능 하다. 

		KColumnReportRecordItem* pColumnItem = (KColumnReportRecordItem*)pRecord->GetItem(_2_COLUMN_IMPORTFIELD_NAME);
		if(0 < pColumnItem->getColumnIndex())
		{
			CXTPReportRecordItemText* pColumnItem = (CXTPReportRecordItemText*)pRecord->GetItem( _0_COLUMN_DEFFILED_NAME );
			KIOColumn* pColumn = (KIOColumn*)(pColumnItem->GetItemData());
			CString strColumnName = pColumn->Name();
			if( 0 != nIdx)
			{
				strPreparedQueryHeader.Append(_T(", "));
				strPreparedQueryValues.Append(_T(", "));
			}
			strPreparedQueryHeader.Append(pColumn->Name());
			strPreparedQueryValues.Append(_T("?"));

			++nIdx;
		}
	}
	strPreparedQueryHeader.Append(_T(")"));
	strPreparedQueryValues.Append(_T(")"));

	CString strPreparedQuery(_T("")); {
		strPreparedQuery.Format(_T(" %s %s "), strPreparedQueryHeader, strPreparedQueryValues);
	}

	return strPreparedQuery;
}

void KDlgImportTurn::ErrorFileOpen()
{
	try
	{
		if (QBicFile::FileExist(m_strErrFile) == false){
			return;
		}
		ShellExecute(NULL, _T("open"), m_strErrFile, NULL, NULL, SW_SHOW); // 기본 프로그램으로 잡혀 있는 프로그램으로 자동 오픈
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}
}

void KDlgImportTurn::ValidateImport( void )
{
	TxLogDebugStartMsg();
	try
	{
		int nBaseDataType = GetBaseDataType();

		CString strColumnName(_T(""));
#pragma region Turn 테이블 필수입력_Filed Null 체크
		CXTPReportRecords* pRecords = m_ctrlReportColumn.GetRecords();
		int nColumnCount = pRecords->GetCount();
		for (int i= 0; i < nColumnCount; i++) {
			CXTPReportRecord* pRecord   = pRecords->GetAt(i);
			KIOColumn*        pIOColumn = nullptr;
			if( pRecord->IsVisible() == FALSE)
				continue;

			int nSelectedIndex = GetImportColumnIndex(pRecord);
			if (nSelectedIndex != 0) // 0이라는 것은 NULL을 선택했다.
				continue;

			CString strMsg(_T(""));
			pIOColumn     = GetDefIOColumn(pRecord);
			strColumnName = pIOColumn->Name();

			if( strColumnName.CompareNoCase(COLUMN_TURN_ID)  == 0 || 
				strColumnName.CompareNoCase(COLUMN_TURN_NODE) == 0 ) {
				//strMsg.Format(_T("\"%s\" Field는 Null일 수 없습니다."), pIOColumn->Caption());
				if (KmzSystem::GetLanguage() == KEMKorea) {
					strMsg.Format(_T("\"%s\" 필수 입력 컬럼은 Null 값일 수 없습니다 !"), pIOColumn->Caption());
				}
				else { //if (KmzSystem::GetLanguage() == KEMEnglish) {
					strMsg.Format(_T("\"%s\" Required input column cannot be a NULL value !"), pIOColumn->Caption());
				}
				ThrowException(strMsg);
			} else if(strColumnName.CompareNoCase(COLUMN_TURN_F_LINK) == 0) {
				if (KmzSystem::GetLanguage() == KEMKorea) {
					if (KEMBaseLink == nBaseDataType) {
						strMsg.Format(_T("\"%s\" 필수 입력 컬럼은 Null 값일 수 없습니다 !"), pIOColumn->Caption());
					}
					else {
						strMsg.Format(_T("\"%s\" 필수 입력 컬럼은 Null 값일 수 없습니다 !"), VIRTUAL_FIELD_FROMNODE);
					}
				}
				else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
					if (KEMBaseLink == nBaseDataType) {
						strMsg.Format(_T("\"%s\" Required input column cannot be a NULL value !"), pIOColumn->Caption());
					}
					else {
						strMsg.Format(_T("\"%s\" Required input column cannot be a NULL value !"), VIRTUAL_FIELD_FROMNODE);
					}
				}
				ThrowException(strMsg);
			} else if(strColumnName.CompareNoCase(COLUMN_TURN_T_LINK) == 0) {
				if (KmzSystem::GetLanguage() == KEMKorea) {
					if (KEMBaseLink == nBaseDataType) {
						strMsg.Format(_T("\"%s\" 필수 입력 컬럼은 Null 값일 수 없습니다 !"), pIOColumn->Caption());
					}
					else {
						strMsg.Format(_T("\"%s\" 필수 입력 컬럼은 Null 값일 수 없습니다 !"), VIRTUAL_FIELD_TONODE);
					}
				}
				else { // if (KmzSystem::GetLanguage() == KEMEnglish) {
					if (KEMBaseLink == nBaseDataType) {
						strMsg.Format(_T("\"%s\" Required input column cannot be a NULL value !"), pIOColumn->Caption());
					}
					else {
						strMsg.Format(_T("\"%s\" Required input column cannot be a NULL value !"), VIRTUAL_FIELD_TONODE);
					}
				}
				
				ThrowException(strMsg);
			}
		}
#pragma endregion Turn 테이블 필수입력_Filed Null 체크
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
		ThrowException((LPCTSTR)strError);
	} catch(KExceptionPtr ex) {
		TxExceptionPrint(ex);
		ThrowException(ex->GetErrorMessage());
	} catch(...) {
		TxLogDebugException();
		ThrowException(_T("Fail - Validate Import"));
	}
	TxLogDebugEndMsg();
}

bool KDlgImportTurn::AlertTableChange()
{
	UpdateData(TRUE);

// 	CString strMsg       = _T("");
// 	bool    bContinue    = false;
// 
// 	KEMImportType emImportType = GetSelectedImportType(); 
// 
// 	if (KEMImportInsert == emImportType) {
// 		if (IsEmptyTable(TABLE_LINK) == false)
// 			strMsg = _T("Link 데이터를 Insert 하면 Turn 과 Transit을 포함한 관련된 테이블의 데이터가 삭제됩니다.\n진행하시겠습니까 ?");
// 		else
// 			return true;
// 	} else {
// 		return true;
// 	}
// 
// 	if ( IDNO == AfxMessageBox(strMsg, MB_YESNO) ) {
// 		return false; 
// 	}

	return true;
}

KIOColumn* KDlgImportTurn::GetDefIOColumn( CXTPReportRecord* a_pRecord )
{
	CXTPReportRecordItemText* pColumnItemText = (CXTPReportRecordItemText*)a_pRecord->GetItem( _0_COLUMN_DEFFILED_NAME );
	KIOColumn*                pIOColumn		  = (KIOColumn*)(pColumnItemText->GetItemData());
	return pIOColumn;
}

int KDlgImportTurn::GetImportColumnIndex( CXTPReportRecord* a_pRecord )
{
	int nColumnIndex = 0;
	KColumnReportRecordItem* pColumnItem = (KColumnReportRecordItem*)a_pRecord->GetItem(_2_COLUMN_IMPORTFIELD_NAME);
	nColumnIndex = pColumnItem->getColumnIndex();
	return nColumnIndex;
}

int KDlgImportTurn::GetBaseDataType()
{
	try
	{
		int nCurSel   = m_cboBaseDataType.GetCurSel();
		int nDataType = (int)m_cboBaseDataType.GetItemData(nCurSel); 

		return nDataType;
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}

	return -1;
}

BOOL KDlgImportTurn::IsAutoGenerateKey()
{
	if (IsDlgButtonChecked(IDC_CHECK3) == BST_CHECKED) {
		return TRUE;
	} else {
		return FALSE;
	}
}

void KDlgImportTurn::OnBnClickedCheckAuto( void )
{
	if (IsDlgButtonChecked(IDC_CHECK3) == BST_CHECKED) {
		GetDlgItem(IDC_EDIT1)->EnableWindow(TRUE);
	} else {
		GetDlgItem(IDC_EDIT1)->EnableWindow(FALSE);
	}

	UpdateColumnView();
}

void KDlgImportTurn::OnSelchangeComboBaseDataType()
{
	UpdateColumnView();
}

void KDlgImportTurn::RelationTableNotify()
{
	TxLogDebugStartMsg();
	try
	{
		KImportCommon::NotifyTurnRelation(m_pTarget);
	} catch (int& ex) {
		CString strError(_T(""));
		strError.Format(_T("Error : %d"), ex);
		TxLogDebug((LPCTSTR)strError);
	} catch (KExceptionPtr ex) {
		TxExceptionPrint(ex);
	} catch (...) {
		TxLogDebugException();
	}

	TxLogDebugEndMsg();
}

void KDlgImportTurn::AddStatusMessage( CString a_strMsg )
{
	QBicSimpleProgressPtr spProgressWindow = QBicSimpleProgressThread::SimpleProgress();
	if(spProgressWindow) {
		spProgressWindow->SetStatus(a_strMsg);
	}
}

void KDlgImportTurn::OnCbnSelchangeCombo4()
{
	if( PriviewLoadCSV() ) {
		InitializeColumnField();
		UpdateColumnView();
		InitializePreview();

		ControlDefaultCheck();
	} 
}

void KDlgImportTurn::OnCbnSelchangeCombo5()
{
	if( PriviewLoadCSV() ) {
		InitializeColumnField();
		UpdateColumnView();
		InitializePreview();

		ControlDefaultCheck();
	} 
}

void KDlgImportTurn::OnBnClickedCheck1()
{
	if( PriviewLoadCSV() ) {
		InitializeColumnField();
		UpdateColumnView();
		InitializePreview();

		ControlDefaultCheck();
	} 
}